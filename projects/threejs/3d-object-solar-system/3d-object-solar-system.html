<!DOCTYPE html>
<html lang="en">
	<head>
		<title>3D Object Planets' Solar System with Trackball Controls</title>
		<meta charset="utf-8">
        <meta name="author" content="Rúben André Barreiro" />
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<style>
			html, body {
				width: 100%;
				height: 100%;
				overflow: hidden;
			}
			
			body {
				color: #000;
				font-family:Monospace;
				font-size:13px;
				text-align:center;
				font-weight: bold;

				background-color: #000000;
				margin: 0px;
			}

			#intro {
				color:#ffffff;
				position: absolute;
				top: 0px; width: 100%;
				padding: 5px;
				box-sizing: border-box;
			}
            
            #info {
				color:#ffffff;
				position: fixed;
				bottom: 0px; left: 0px;
				padding: 5px;
				box-sizing: border-box;
                text-align: left
			}
            
            #objectName {
                text-decoration: underline;
                font-style: italic;
                font-weight: bold;
                font-size: 40px;
            }
            
            #objectObservationDataTitle {
                font-weight: bold;
                font-size: 20px;
            }
            
            #objectObservationDataContent {
                font-size: 10px;
            }
            
			a {
				color: red;
			}
		</style>
	</head>

	<body>
		<div id="intro">
            <h1>3D Object's Solar System</h1>
            <h3>with Sun, Planets, Moons, Orbits and Trackball Controls</h3>
            <br/>
            Made with <a href="http://threejs.org" target="_blank" rel="noopener">three.js</a> by <a href="https://rubenandrebarreiro.github.io/" target="_blank" rel="noopener"> Rúben André Barreiro</a>
            <br/>
            <br/>
            <h2><b>INSTRUCTIONS:</b></h2>
            MOVE mouse &amp; press LEFT/A: rotate, MIDDLE/S: zoom, RIGHT/D: pan
            <br>
            <h3>NOTES:</h3>
            <b>Just for visualization's purposes:</b>
            <br/>
            1) The <u><i>Sun</i></u> and <u><i>Planets</i></u>' radius are using a scale of 10<sup>-3</sup> KMs
            <br/>
            2) The <u><i>Planets</i></u>' radius are using a scale of 10<sup>-4</sup> KMs
		</div>
        
        <div id="info">
            <span id="objectName"></span>
            <br/>
            <br/>
            <span id="objectObservationDataTitle"></span>
            <br/>
            <textarea rows="8" cols="100" id="objectObservationDataContent" style="background: transparent; border: 0 none; resize: none; color: white"></textarea>
        </div>

		<script src="../common/build/three.js"></script>
        
		<script src="../common/js/controls/TrackballControls.js"></script>

		<script src="../common/js/WebGL.js"></script>
        <script src="../common/js/Detector.js"></script>
        <script src="../common/js/renderers/Projector.js"></script>
		<script src="../common/js/libs/stats.min.js"></script>

		<script>

			if(WEBGL.isWebGLAvailable() === false) {
                document.body.appendChild(WEBGL.getWebGLErrorMessage());
			}

			var camera, controls, solarSystemScene, renderer, stats;

            var projector, mouse = { x: window.innerHeight, y: window.innerWidth };
            
            var SUN_INTERSECTED;
            
            var MERCURY_INTERSECTED;
            
            var loader = new THREE.TextureLoader();
            loader.setCrossOrigin("");
            
            const yAxis = new THREE.Vector3(0, 1, 0).normalize();

            // Sun Element
            var sunMesh;
            
            // Mercury's Elements
            var mercuryOrbitMesh, mercuryPlanetMesh, mercuryPivot;

            
			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 100000);
				camera.position.y = 20;
                camera.position.z = 40000;
                
				controls = new THREE.TrackballControls(camera);

				controls.rotateSpeed = 1.0;
				controls.zoomSpeed = 1.2;
				controls.panSpeed = 0.8;

				controls.noZoom = false;
				controls.noPan = false;

				controls.staticMoving = true;
				controls.dynamicDampingFactor = 0.3;

				controls.keys = [ 65, 83, 68 ];

				controls.addEventListener('change', render);

				// Creating the Galaxy's Scene
				solarSystemScene = new THREE.Scene();
                
                
                var gridXZ = new THREE.GridHelper(80000, 20, new THREE.Color(0xff0000), new THREE.Color(0xffffff));
                solarSystemScene.add(gridXZ);
				
                backgroundTexture = loader.load("imgs/stars-milky-way.jpg",
                    function (texture) {
                       var image = texture.image;
                       var backgroundWidth= image.width;
                       var backgroundHeight = image.height;
                       onWindowResize();
                    }
                );

                solarSystemScene.background = backgroundTexture;
                backgroundTexture.wrapS = THREE.MirroredRepeatWrapping;
                backgroundTexture.wrapT = THREE.MirroredRepeatWrapping;
                
                // Adding the elements (Sun, Planets and their respective Orbits and Moons)
                
                // INFO:
                // 1) It will be used a size scale of 0.001 kms to determine the size of the planets
                // 2) It will be used a size scale of 0.000,1 kms to determine the radius of the planets' orbits
                // The final size of each planet and their respective orbits will be rounded to the units or to the first decimal, since it's possible
                
                // 1) SUN's setup
                sunTexture = loader.load('imgs/sun-texture.jpg', function (texture) {});
                
                // The radius of Sun is 695,508 kms (Resolution: [695,508 * 0.01] = 696)
                var sunGeometry = new THREE.SphereGeometry(696, 40, 40);
                var sunMaterial = new THREE.MeshBasicMaterial(
                    {
                        map: sunTexture,
                        overdraw: 0.5
                    }
                );

                sunMesh = new THREE.Mesh(sunGeometry, sunMaterial);
                
                sunMesh.textName = "Sun";
                sunMesh.textObservationDataContent = {a: "- Mean distance from Earth: 1 au ≈ 1.496×108 km (8 min 19 s at light speed)", b: "- Visual brightness (V): −26.74", c: "- Absolute magnitude: 4.83", d: "- Spectral classification: G2V", e: "- Metallicity: Z = 0.0122", f: "- Angular size: 31.6–32.7 minutes of arc", g: "- Adjectives: Solar"};
                
                solarSystemScene.add(sunMesh);
                
                
                // 2) MERCURY's setup
                
                // The average distance/orbit's radius from the Sun ranging from 46,000,000 kms to 70,000,000 kms
                // It will be used an average orbit's radius of an interval between 57,500,000 and 58,000,000 (Resolution: [57,500,000 * 0.000,1] = 5,750 and [58,000,000 * 0.000,1] = 5,800)
                var mercuryOrbitGeometry = new THREE.RingGeometry(5750, 5800, 60);
                var mercuryOrbitMaterial = new THREE.MeshBasicMaterial(
                    {
                        color: 0xffff00,
                        side: THREE.DoubleSide
                    }
                );
                
                mercuryOrbitMesh = new THREE.Mesh(mercuryOrbitGeometry, mercuryOrbitMaterial);
                mercuryOrbitMesh.rotation.x = Math.PI / 2;
                
                
                mercuryPlanetTexture = loader.load('imgs/mercury-planet-texture.jpg', function (texture) {});
                
                // The radius of Mercury is 2,440 kms (Resolution: [2,440 * 0.001] = 2)
                var mercuryPlanetGeometry = new THREE.SphereGeometry(240, 40, 40);
                var mercuryPlanetMaterial = new THREE.MeshBasicMaterial(
                    {
                        map: mercuryPlanetTexture,
                        overdraw: 0.5
                    }
                );
                
                mercuryPlanetMesh = new THREE.Mesh(mercuryPlanetGeometry, mercuryPlanetMaterial);            
                mercuryPlanetMesh.position.z = 5775;
                
                mercuryPlanetMesh.name = "Mercury";
                
                mercuryPivot = new THREE.Group();
                
                mercuryPivot.add(mercuryOrbitMesh);
                mercuryPivot.add(mercuryPlanetMesh);
                
                mercuryPivot.position.x = -1600;
                
                solarSystemScene.add(mercuryPivot);
                
                
                // Creating all the solar system's scene's lights
				var directionalLight1 = new THREE.DirectionalLight(0xffffff);
				directionalLight1.position.set(1, 1, 1);
				solarSystemScene.add(directionalLight1);

				var directionalLight2 = new THREE.DirectionalLight(0x002288);
				directionalLight2.position.set(- 1, - 1, - 1);
				solarSystemScene.add(directionalLight2);

				var ambientLight = new THREE.AmbientLight(0x222222);
				solarSystemScene.add(ambientLight);

				
                // Creating the renderer
				renderer = new THREE.WebGLRenderer(
                    {
                        antialias: true
                    }
                );
				
                renderer.setPixelRatio(window.devicePixelRatio);
				renderer.setSize(window.innerWidth, window.innerHeight);
				document.body.appendChild(renderer.domElement);

				stats = new Stats();
				document.body.appendChild(stats.dom);

				window.addEventListener('resize', onWindowResize, false);
                
                // Initialize object to perform world/screen calculations
                projector = new THREE.Projector();

                // When the mouse moves, call the given function
                document.addEventListener('mousemove', onDocumentMouseMove, false);

                render();
			}

			function onWindowResize() {
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize(window.innerWidth, window.innerHeight);

				controls.handleResize();

				render();
			}
            
            function onDocumentMouseMove(event) {
                // The following line would stop any other event handler from firing
                // (such as the mouse's TrackballControls)
                // event.preventDefault();

                // Update the mouse variable
                mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
                mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;
            }
            
			function animate() {
			    requestAnimationFrame(animate);
				
                findIntersectionsSun();
                
                findIntersectionsMercury();
                
				controls.update();
				
				stats.update();
			}

            function findIntersectionsSun() {
                // Create a Ray with origin at the mouse position
                // and direction into the scene (camera direction)
                var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                projector.unprojectVector(vector, camera);
                
                var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                // Create an array containing all objects in the scene with which the ray intersects
                var intersects = ray.intersectObjects(solarSystemScene.children);
                
                // SUN_INTERSECTED = the object in the scene currently closest to the camera 
                // and intersected by the Ray projected from the mouse position 	

                // If there is one (or more) intersections
                if(intersects.length > 0) {
                    
                    // If the closest object intersected is not the currently stored intersection object
                    if(intersects[0].object != SUN_INTERSECTED) {
                        // Restore previous intersection object (if it exists) to its original map's texture
                        if(SUN_INTERSECTED) {
                            SUN_INTERSECTED.material.needsUpdate = true;
                            
                            SUN_INTERSECTED.material.color.setHex(0xffffff);
                            SUN_INTERSECTED.material.map = SUN_INTERSECTED.mapTexture;
                        
                            document.getElementById("objectName").textContent = "";
                            document.getElementById("objectObservationDataTitle").textContent = "";
                            document.getElementById("objectObservationDataContent").value = "";
                        }
                        
                        // Store reference to closest object as current intersection object
                        SUN_INTERSECTED = intersects[0].object;
                        
                        // Store color and map's texture of closest object (for later restoration)
                        SUN_INTERSECTED.mapTexture = SUN_INTERSECTED.material.map;
                        
                        // Set a new color for closest object
                        SUN_INTERSECTED.material.map = null;
                        SUN_INTERSECTED.material.needsUpdate = true;
                        
                        SUN_INTERSECTED.material.color.setHex(0xffff00);
                        
                        document.getElementById("objectName").textContent = intersects[0].object.textName;
                        document.getElementById("objectObservationDataTitle").textContent = "Observation Data:"; 
                        
                        var sunObservationData = sunMesh.textObservationDataContent.a + "\n" + sunMesh.textObservationDataContent.b + "\n" + sunMesh.textObservationDataContent.c + "\n" + sunMesh.textObservationDataContent.d + "\n" + sunMesh.textObservationDataContent.e + "\n" + sunMesh.textObservationDataContent.f + "\n" + sunMesh.textObservationDataContent.g;
                        
                        document.getElementById("objectObservationDataContent").value = sunObservationData;
                    }
                } 
                else { // There are no intersections
                    
                    // Restore previous intersection object (if it exists) to its original map's texture
                    if(SUN_INTERSECTED) {
                        SUN_INTERSECTED.material.needsUpdate = true;

                        SUN_INTERSECTED.material.color.setHex(0xffffff);
                        SUN_INTERSECTED.material.map = SUN_INTERSECTED.mapTexture;
                        
                        document.getElementById("objectName").textContent = "";
                        document.getElementById("objectObservationDataTitle").textContent = "";
                        document.getElementById("objectObservationDataContent").value = "";
                    }
                    
                    // Remove previous intersection object reference
                    // by setting current intersection object to "nothing"
                    SUN_INTERSECTED = null;
                }
            }
            
            function findIntersectionsMercury() {
                // Create a Ray with origin at the mouse position
                // and direction into the scene (camera direction)
                var vector = new THREE.Vector3(mouse.x, mouse.y, 1);
                projector.unprojectVector(vector, camera);
                
                var ray = new THREE.Raycaster(camera.position, vector.sub(camera.position).normalize());

                // Create an array containing all objects in the scene with which the ray intersects
                var intersects = ray.intersectObjects(mercuryPivot.children);
                
                // MERCURY_INTERSECTED = the object in the scene currently closest to the camera 
                // and intersected by the Ray projected from the mouse position 	

                // If there is one (or more) intersections
                if(intersects.length > 0) {
                    
                    // If the closest object intersected is not the currently stored intersection object
                    if(intersects[0].object != MERCURY_INTERSECTED) {
                        // Restore previous intersection object (if it exists) to its original map's texture
                        if(MERCURY_INTERSECTED) {
                            MERCURY_INTERSECTED.material.needsUpdate = true;
                            MERCURY_INTERSECTED.material.color.setHex(0xffffff);
                            
                            MERCURY_INTERSECTED.material.map = MERCURY_INTERSECTED.mapTexture;
                        }
                        
                        // Store reference to closest object as current intersection object
                        MERCURY_INTERSECTED = intersects[0].object;
                        
                        // Store color and map's texture of closest object (for later restoration)
                        MERCURY_INTERSECTED.mapTexture = MERCURY_INTERSECTED.material.map;
                        
                        // Set a new color for closest object
                        MERCURY_INTERSECTED.material.map = null;
                        MERCURY_INTERSECTED.material.needsUpdate = true;
                        
                        MERCURY_INTERSECTED.material.color.setHex(0xffff00);
                    }
                } 
                else { // There are no intersections
                    
                    // Restore previous intersection object (if it exists) to its original map's texture
                    if(MERCURY_INTERSECTED) {
                        MERCURY_INTERSECTED.material.needsUpdate = true;
                        
                        MERCURY_INTERSECTED.material.color.setHex(0xffffff);
                        MERCURY_INTERSECTED.material.map = MERCURY_INTERSECTED.mapTexture;
                    }
                    
                    // Remove previous intersection object reference
                    // by setting current intersection object to "nothing"
                    MERCURY_INTERSECTED = null;
                }
            }
            
            // Sun and Planets' rotation movements
            function rotationMovements() {
                var speedRotationSun = 0.0001 * 27;
                var speedRotationMercuryPlanet = 0.00001 * 58;
                
                sunMesh.rotation.y += speedRotationSun;
                
                mercuryPlanetMesh.rotation.y += speedRotationMercuryPlanet;   
            }
            
            // Planets' translaction movements around the sun
            function translactionMovements() {
                
                // Creating the quarternion for the planet Mercury
                var quaternionForMercuryPlanet = new THREE.Quaternion();
                
                quaternionForMercuryPlanet.setFromAxisAngle(yAxis, 0.00005);
                mercuryPlanetMesh.position.applyQuaternion(quaternionForMercuryPlanet);   
            }
            
			function render() {
                requestAnimationFrame(render);
                rotationMovements();
                translactionMovements();
				renderer.render(solarSystemScene, camera);
			}
		</script>
	</body>
</html>